// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package mdbmodels

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// File is an object representing the database table.
type File struct {
	ID              int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	UID             string      `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	Name            string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Size            int64       `boil:"size" json:"size" toml:"size" yaml:"size"`
	Type            string      `boil:"type" json:"type" toml:"type" yaml:"type"`
	SubType         string      `boil:"sub_type" json:"sub_type" toml:"sub_type" yaml:"sub_type"`
	MimeType        null.String `boil:"mime_type" json:"mime_type,omitempty" toml:"mime_type" yaml:"mime_type,omitempty"`
	Sha1            null.Bytes  `boil:"sha1" json:"sha1,omitempty" toml:"sha1" yaml:"sha1,omitempty"`
	ContentUnitID   null.Int64  `boil:"content_unit_id" json:"content_unit_id,omitempty" toml:"content_unit_id" yaml:"content_unit_id,omitempty"`
	CreatedAt       time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	Language        null.String `boil:"language" json:"language,omitempty" toml:"language" yaml:"language,omitempty"`
	BackupCount     null.Int16  `boil:"backup_count" json:"backup_count,omitempty" toml:"backup_count" yaml:"backup_count,omitempty"`
	FirstBackupTime null.Time   `boil:"first_backup_time" json:"first_backup_time,omitempty" toml:"first_backup_time" yaml:"first_backup_time,omitempty"`
	Properties      null.JSON   `boil:"properties" json:"properties,omitempty" toml:"properties" yaml:"properties,omitempty"`
	ParentID        null.Int64  `boil:"parent_id" json:"parent_id,omitempty" toml:"parent_id" yaml:"parent_id,omitempty"`
	FileCreatedAt   null.Time   `boil:"file_created_at" json:"file_created_at,omitempty" toml:"file_created_at" yaml:"file_created_at,omitempty"`
	Secure          int16       `boil:"secure" json:"secure" toml:"secure" yaml:"secure"`
	Published       bool        `boil:"published" json:"published" toml:"published" yaml:"published"`
	RemovedAt       null.Time   `boil:"removed_at" json:"removed_at,omitempty" toml:"removed_at" yaml:"removed_at,omitempty"`

	R *fileR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L fileL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var FileColumns = struct {
	ID              string
	UID             string
	Name            string
	Size            string
	Type            string
	SubType         string
	MimeType        string
	Sha1            string
	ContentUnitID   string
	CreatedAt       string
	Language        string
	BackupCount     string
	FirstBackupTime string
	Properties      string
	ParentID        string
	FileCreatedAt   string
	Secure          string
	Published       string
	RemovedAt       string
}{
	ID:              "id",
	UID:             "uid",
	Name:            "name",
	Size:            "size",
	Type:            "type",
	SubType:         "sub_type",
	MimeType:        "mime_type",
	Sha1:            "sha1",
	ContentUnitID:   "content_unit_id",
	CreatedAt:       "created_at",
	Language:        "language",
	BackupCount:     "backup_count",
	FirstBackupTime: "first_backup_time",
	Properties:      "properties",
	ParentID:        "parent_id",
	FileCreatedAt:   "file_created_at",
	Secure:          "secure",
	Published:       "published",
	RemovedAt:       "removed_at",
}

var FileTableColumns = struct {
	ID              string
	UID             string
	Name            string
	Size            string
	Type            string
	SubType         string
	MimeType        string
	Sha1            string
	ContentUnitID   string
	CreatedAt       string
	Language        string
	BackupCount     string
	FirstBackupTime string
	Properties      string
	ParentID        string
	FileCreatedAt   string
	Secure          string
	Published       string
	RemovedAt       string
}{
	ID:              "files.id",
	UID:             "files.uid",
	Name:            "files.name",
	Size:            "files.size",
	Type:            "files.type",
	SubType:         "files.sub_type",
	MimeType:        "files.mime_type",
	Sha1:            "files.sha1",
	ContentUnitID:   "files.content_unit_id",
	CreatedAt:       "files.created_at",
	Language:        "files.language",
	BackupCount:     "files.backup_count",
	FirstBackupTime: "files.first_backup_time",
	Properties:      "files.properties",
	ParentID:        "files.parent_id",
	FileCreatedAt:   "files.file_created_at",
	Secure:          "files.secure",
	Published:       "files.published",
	RemovedAt:       "files.removed_at",
}

// Generated where

type whereHelpernull_Bytes struct{ field string }

func (w whereHelpernull_Bytes) EQ(x null.Bytes) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bytes) NEQ(x null.Bytes) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bytes) LT(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bytes) LTE(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bytes) GT(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bytes) GTE(x null.Bytes) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bytes) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bytes) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int16 struct{ field string }

func (w whereHelpernull_Int16) EQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int16) NEQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int16) LT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int16) LTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int16) GT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int16) GTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int16) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int16) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var FileWhere = struct {
	ID              whereHelperint64
	UID             whereHelperstring
	Name            whereHelperstring
	Size            whereHelperint64
	Type            whereHelperstring
	SubType         whereHelperstring
	MimeType        whereHelpernull_String
	Sha1            whereHelpernull_Bytes
	ContentUnitID   whereHelpernull_Int64
	CreatedAt       whereHelpertime_Time
	Language        whereHelpernull_String
	BackupCount     whereHelpernull_Int16
	FirstBackupTime whereHelpernull_Time
	Properties      whereHelpernull_JSON
	ParentID        whereHelpernull_Int64
	FileCreatedAt   whereHelpernull_Time
	Secure          whereHelperint16
	Published       whereHelperbool
	RemovedAt       whereHelpernull_Time
}{
	ID:              whereHelperint64{field: "\"files\".\"id\""},
	UID:             whereHelperstring{field: "\"files\".\"uid\""},
	Name:            whereHelperstring{field: "\"files\".\"name\""},
	Size:            whereHelperint64{field: "\"files\".\"size\""},
	Type:            whereHelperstring{field: "\"files\".\"type\""},
	SubType:         whereHelperstring{field: "\"files\".\"sub_type\""},
	MimeType:        whereHelpernull_String{field: "\"files\".\"mime_type\""},
	Sha1:            whereHelpernull_Bytes{field: "\"files\".\"sha1\""},
	ContentUnitID:   whereHelpernull_Int64{field: "\"files\".\"content_unit_id\""},
	CreatedAt:       whereHelpertime_Time{field: "\"files\".\"created_at\""},
	Language:        whereHelpernull_String{field: "\"files\".\"language\""},
	BackupCount:     whereHelpernull_Int16{field: "\"files\".\"backup_count\""},
	FirstBackupTime: whereHelpernull_Time{field: "\"files\".\"first_backup_time\""},
	Properties:      whereHelpernull_JSON{field: "\"files\".\"properties\""},
	ParentID:        whereHelpernull_Int64{field: "\"files\".\"parent_id\""},
	FileCreatedAt:   whereHelpernull_Time{field: "\"files\".\"file_created_at\""},
	Secure:          whereHelperint16{field: "\"files\".\"secure\""},
	Published:       whereHelperbool{field: "\"files\".\"published\""},
	RemovedAt:       whereHelpernull_Time{field: "\"files\".\"removed_at\""},
}

// FileRels is where relationship names are stored.
var FileRels = struct {
	ContentUnit string
	Parent      string
	ParentFiles string
	Operations  string
	Storages    string
}{
	ContentUnit: "ContentUnit",
	Parent:      "Parent",
	ParentFiles: "ParentFiles",
	Operations:  "Operations",
	Storages:    "Storages",
}

// fileR is where relationships are stored.
type fileR struct {
	ContentUnit *ContentUnit   `boil:"ContentUnit" json:"ContentUnit" toml:"ContentUnit" yaml:"ContentUnit"`
	Parent      *File          `boil:"Parent" json:"Parent" toml:"Parent" yaml:"Parent"`
	ParentFiles FileSlice      `boil:"ParentFiles" json:"ParentFiles" toml:"ParentFiles" yaml:"ParentFiles"`
	Operations  OperationSlice `boil:"Operations" json:"Operations" toml:"Operations" yaml:"Operations"`
	Storages    StorageSlice   `boil:"Storages" json:"Storages" toml:"Storages" yaml:"Storages"`
}

// NewStruct creates a new relationship struct
func (*fileR) NewStruct() *fileR {
	return &fileR{}
}

// fileL is where Load methods for each relationship are stored.
type fileL struct{}

var (
	fileAllColumns            = []string{"id", "uid", "name", "size", "type", "sub_type", "mime_type", "sha1", "content_unit_id", "created_at", "language", "backup_count", "first_backup_time", "properties", "parent_id", "file_created_at", "secure", "published", "removed_at"}
	fileColumnsWithoutDefault = []string{"uid", "name", "size", "type", "sub_type"}
	fileColumnsWithDefault    = []string{"id", "mime_type", "sha1", "content_unit_id", "created_at", "language", "backup_count", "first_backup_time", "properties", "parent_id", "file_created_at", "secure", "published", "removed_at"}
	filePrimaryKeyColumns     = []string{"id"}
	fileGeneratedColumns      = []string{}
)

type (
	// FileSlice is an alias for a slice of pointers to File.
	// This should almost always be used instead of []File.
	FileSlice []*File

	fileQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	fileType                 = reflect.TypeOf(&File{})
	fileMapping              = queries.MakeStructMapping(fileType)
	filePrimaryKeyMapping, _ = queries.BindMapping(fileType, fileMapping, filePrimaryKeyColumns)
	fileInsertCacheMut       sync.RWMutex
	fileInsertCache          = make(map[string]insertCache)
	fileUpdateCacheMut       sync.RWMutex
	fileUpdateCache          = make(map[string]updateCache)
	fileUpsertCacheMut       sync.RWMutex
	fileUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single file record from the query.
func (q fileQuery) One(exec boil.Executor) (*File, error) {
	o := &File{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mdbmodels: failed to execute a one query for files")
	}

	return o, nil
}

// All returns all File records from the query.
func (q fileQuery) All(exec boil.Executor) (FileSlice, error) {
	var o []*File

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "mdbmodels: failed to assign all query results to File slice")
	}

	return o, nil
}

// Count returns the count of all File records in the query.
func (q fileQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: failed to count files rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q fileQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "mdbmodels: failed to check if files exists")
	}

	return count > 0, nil
}

// ContentUnit pointed to by the foreign key.
func (o *File) ContentUnit(mods ...qm.QueryMod) contentUnitQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ContentUnitID),
	}

	queryMods = append(queryMods, mods...)

	query := ContentUnits(queryMods...)
	queries.SetFrom(query.Query, "\"content_units\"")

	return query
}

// Parent pointed to by the foreign key.
func (o *File) Parent(mods ...qm.QueryMod) fileQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ParentID),
	}

	queryMods = append(queryMods, mods...)

	query := Files(queryMods...)
	queries.SetFrom(query.Query, "\"files\"")

	return query
}

// ParentFiles retrieves all the file's Files with an executor via parent_id column.
func (o *File) ParentFiles(mods ...qm.QueryMod) fileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"files\".\"parent_id\"=?", o.ID),
	)

	query := Files(queryMods...)
	queries.SetFrom(query.Query, "\"files\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"files\".*"})
	}

	return query
}

// Operations retrieves all the operation's Operations with an executor.
func (o *File) Operations(mods ...qm.QueryMod) operationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"files_operations\" on \"operations\".\"id\" = \"files_operations\".\"operation_id\""),
		qm.Where("\"files_operations\".\"file_id\"=?", o.ID),
	)

	query := Operations(queryMods...)
	queries.SetFrom(query.Query, "\"operations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"operations\".*"})
	}

	return query
}

// Storages retrieves all the storage's Storages with an executor.
func (o *File) Storages(mods ...qm.QueryMod) storageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"files_storages\" on \"storages\".\"id\" = \"files_storages\".\"storage_id\""),
		qm.Where("\"files_storages\".\"file_id\"=?", o.ID),
	)

	query := Storages(queryMods...)
	queries.SetFrom(query.Query, "\"storages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"storages\".*"})
	}

	return query
}

// LoadContentUnit allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fileL) LoadContentUnit(e boil.Executor, singular bool, maybeFile interface{}, mods queries.Applicator) error {
	var slice []*File
	var object *File

	if singular {
		object = maybeFile.(*File)
	} else {
		slice = *maybeFile.(*[]*File)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fileR{}
		}
		if !queries.IsNil(object.ContentUnitID) {
			args = append(args, object.ContentUnitID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fileR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ContentUnitID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ContentUnitID) {
				args = append(args, obj.ContentUnitID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`content_units`),
		qm.WhereIn(`content_units.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ContentUnit")
	}

	var resultSlice []*ContentUnit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ContentUnit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for content_units")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for content_units")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ContentUnit = foreign
		if foreign.R == nil {
			foreign.R = &contentUnitR{}
		}
		foreign.R.Files = append(foreign.R.Files, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ContentUnitID, foreign.ID) {
				local.R.ContentUnit = foreign
				if foreign.R == nil {
					foreign.R = &contentUnitR{}
				}
				foreign.R.Files = append(foreign.R.Files, local)
				break
			}
		}
	}

	return nil
}

// LoadParent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fileL) LoadParent(e boil.Executor, singular bool, maybeFile interface{}, mods queries.Applicator) error {
	var slice []*File
	var object *File

	if singular {
		object = maybeFile.(*File)
	} else {
		slice = *maybeFile.(*[]*File)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fileR{}
		}
		if !queries.IsNil(object.ParentID) {
			args = append(args, object.ParentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fileR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ParentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ParentID) {
				args = append(args, obj.ParentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`files`),
		qm.WhereIn(`files.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load File")
	}

	var resultSlice []*File
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice File")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for files")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for files")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Parent = foreign
		if foreign.R == nil {
			foreign.R = &fileR{}
		}
		foreign.R.ParentFiles = append(foreign.R.ParentFiles, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ParentID, foreign.ID) {
				local.R.Parent = foreign
				if foreign.R == nil {
					foreign.R = &fileR{}
				}
				foreign.R.ParentFiles = append(foreign.R.ParentFiles, local)
				break
			}
		}
	}

	return nil
}

// LoadParentFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (fileL) LoadParentFiles(e boil.Executor, singular bool, maybeFile interface{}, mods queries.Applicator) error {
	var slice []*File
	var object *File

	if singular {
		object = maybeFile.(*File)
	} else {
		slice = *maybeFile.(*[]*File)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fileR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fileR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`files`),
		qm.WhereIn(`files.parent_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load files")
	}

	var resultSlice []*File
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice files")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on files")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for files")
	}

	if singular {
		object.R.ParentFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fileR{}
			}
			foreign.R.Parent = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ParentID) {
				local.R.ParentFiles = append(local.R.ParentFiles, foreign)
				if foreign.R == nil {
					foreign.R = &fileR{}
				}
				foreign.R.Parent = local
				break
			}
		}
	}

	return nil
}

// LoadOperations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (fileL) LoadOperations(e boil.Executor, singular bool, maybeFile interface{}, mods queries.Applicator) error {
	var slice []*File
	var object *File

	if singular {
		object = maybeFile.(*File)
	} else {
		slice = *maybeFile.(*[]*File)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fileR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fileR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"operations\".id, \"operations\".uid, \"operations\".type_id, \"operations\".created_at, \"operations\".station, \"operations\".user_id, \"operations\".details, \"operations\".properties, \"a\".\"file_id\""),
		qm.From("\"operations\""),
		qm.InnerJoin("\"files_operations\" as \"a\" on \"operations\".\"id\" = \"a\".\"operation_id\""),
		qm.WhereIn("\"a\".\"file_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load operations")
	}

	var resultSlice []*Operation

	var localJoinCols []int64
	for results.Next() {
		one := new(Operation)
		var localJoinCol int64

		err = results.Scan(&one.ID, &one.UID, &one.TypeID, &one.CreatedAt, &one.Station, &one.UserID, &one.Details, &one.Properties, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for operations")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice operations")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on operations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for operations")
	}

	if singular {
		object.R.Operations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &operationR{}
			}
			foreign.R.Files = append(foreign.R.Files, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Operations = append(local.R.Operations, foreign)
				if foreign.R == nil {
					foreign.R = &operationR{}
				}
				foreign.R.Files = append(foreign.R.Files, local)
				break
			}
		}
	}

	return nil
}

// LoadStorages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (fileL) LoadStorages(e boil.Executor, singular bool, maybeFile interface{}, mods queries.Applicator) error {
	var slice []*File
	var object *File

	if singular {
		object = maybeFile.(*File)
	} else {
		slice = *maybeFile.(*[]*File)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fileR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fileR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"storages\".id, \"storages\".name, \"storages\".country, \"storages\".location, \"storages\".status, \"storages\".access, \"a\".\"file_id\""),
		qm.From("\"storages\""),
		qm.InnerJoin("\"files_storages\" as \"a\" on \"storages\".\"id\" = \"a\".\"storage_id\""),
		qm.WhereIn("\"a\".\"file_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load storages")
	}

	var resultSlice []*Storage

	var localJoinCols []int64
	for results.Next() {
		one := new(Storage)
		var localJoinCol int64

		err = results.Scan(&one.ID, &one.Name, &one.Country, &one.Location, &one.Status, &one.Access, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for storages")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice storages")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on storages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for storages")
	}

	if singular {
		object.R.Storages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &storageR{}
			}
			foreign.R.Files = append(foreign.R.Files, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Storages = append(local.R.Storages, foreign)
				if foreign.R == nil {
					foreign.R = &storageR{}
				}
				foreign.R.Files = append(foreign.R.Files, local)
				break
			}
		}
	}

	return nil
}

// SetContentUnit of the file to the related item.
// Sets o.R.ContentUnit to related.
// Adds o to related.R.Files.
func (o *File) SetContentUnit(exec boil.Executor, insert bool, related *ContentUnit) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"files\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"content_unit_id"}),
		strmangle.WhereClause("\"", "\"", 2, filePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ContentUnitID, related.ID)
	if o.R == nil {
		o.R = &fileR{
			ContentUnit: related,
		}
	} else {
		o.R.ContentUnit = related
	}

	if related.R == nil {
		related.R = &contentUnitR{
			Files: FileSlice{o},
		}
	} else {
		related.R.Files = append(related.R.Files, o)
	}

	return nil
}

// RemoveContentUnit relationship.
// Sets o.R.ContentUnit to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *File) RemoveContentUnit(exec boil.Executor, related *ContentUnit) error {
	var err error

	queries.SetScanner(&o.ContentUnitID, nil)
	if _, err = o.Update(exec, boil.Whitelist("content_unit_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ContentUnit = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Files {
		if queries.Equal(o.ContentUnitID, ri.ContentUnitID) {
			continue
		}

		ln := len(related.R.Files)
		if ln > 1 && i < ln-1 {
			related.R.Files[i] = related.R.Files[ln-1]
		}
		related.R.Files = related.R.Files[:ln-1]
		break
	}
	return nil
}

// SetParent of the file to the related item.
// Sets o.R.Parent to related.
// Adds o to related.R.ParentFiles.
func (o *File) SetParent(exec boil.Executor, insert bool, related *File) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"files\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"parent_id"}),
		strmangle.WhereClause("\"", "\"", 2, filePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ParentID, related.ID)
	if o.R == nil {
		o.R = &fileR{
			Parent: related,
		}
	} else {
		o.R.Parent = related
	}

	if related.R == nil {
		related.R = &fileR{
			ParentFiles: FileSlice{o},
		}
	} else {
		related.R.ParentFiles = append(related.R.ParentFiles, o)
	}

	return nil
}

// RemoveParent relationship.
// Sets o.R.Parent to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *File) RemoveParent(exec boil.Executor, related *File) error {
	var err error

	queries.SetScanner(&o.ParentID, nil)
	if _, err = o.Update(exec, boil.Whitelist("parent_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Parent = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ParentFiles {
		if queries.Equal(o.ParentID, ri.ParentID) {
			continue
		}

		ln := len(related.R.ParentFiles)
		if ln > 1 && i < ln-1 {
			related.R.ParentFiles[i] = related.R.ParentFiles[ln-1]
		}
		related.R.ParentFiles = related.R.ParentFiles[:ln-1]
		break
	}
	return nil
}

// AddParentFiles adds the given related objects to the existing relationships
// of the file, optionally inserting them as new records.
// Appends related to o.R.ParentFiles.
// Sets related.R.Parent appropriately.
func (o *File) AddParentFiles(exec boil.Executor, insert bool, related ...*File) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"files\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"parent_id"}),
				strmangle.WhereClause("\"", "\"", 2, filePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &fileR{
			ParentFiles: related,
		}
	} else {
		o.R.ParentFiles = append(o.R.ParentFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fileR{
				Parent: o,
			}
		} else {
			rel.R.Parent = o
		}
	}
	return nil
}

// SetParentFiles removes all previously related items of the
// file replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Parent's ParentFiles accordingly.
// Replaces o.R.ParentFiles with related.
// Sets related.R.Parent's ParentFiles accordingly.
func (o *File) SetParentFiles(exec boil.Executor, insert bool, related ...*File) error {
	query := "update \"files\" set \"parent_id\" = null where \"parent_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentFiles {
			queries.SetScanner(&rel.ParentID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Parent = nil
		}

		o.R.ParentFiles = nil
	}
	return o.AddParentFiles(exec, insert, related...)
}

// RemoveParentFiles relationships from objects passed in.
// Removes related items from R.ParentFiles (uses pointer comparison, removal does not keep order)
// Sets related.R.Parent.
func (o *File) RemoveParentFiles(exec boil.Executor, related ...*File) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentID, nil)
		if rel.R != nil {
			rel.R.Parent = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("parent_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentFiles {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentFiles)
			if ln > 1 && i < ln-1 {
				o.R.ParentFiles[i] = o.R.ParentFiles[ln-1]
			}
			o.R.ParentFiles = o.R.ParentFiles[:ln-1]
			break
		}
	}

	return nil
}

// AddOperations adds the given related objects to the existing relationships
// of the file, optionally inserting them as new records.
// Appends related to o.R.Operations.
// Sets related.R.Files appropriately.
func (o *File) AddOperations(exec boil.Executor, insert bool, related ...*Operation) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"files_operations\" (\"file_id\", \"operation_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, query)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		_, err = exec.Exec(query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &fileR{
			Operations: related,
		}
	} else {
		o.R.Operations = append(o.R.Operations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &operationR{
				Files: FileSlice{o},
			}
		} else {
			rel.R.Files = append(rel.R.Files, o)
		}
	}
	return nil
}

// SetOperations removes all previously related items of the
// file replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Files's Operations accordingly.
// Replaces o.R.Operations with related.
// Sets related.R.Files's Operations accordingly.
func (o *File) SetOperations(exec boil.Executor, insert bool, related ...*Operation) error {
	query := "delete from \"files_operations\" where \"file_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeOperationsFromFilesSlice(o, related)
	if o.R != nil {
		o.R.Operations = nil
	}
	return o.AddOperations(exec, insert, related...)
}

// RemoveOperations relationships from objects passed in.
// Removes related items from R.Operations (uses pointer comparison, removal does not keep order)
// Sets related.R.Files.
func (o *File) RemoveOperations(exec boil.Executor, related ...*Operation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"files_operations\" where \"file_id\" = $1 and \"operation_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeOperationsFromFilesSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Operations {
			if rel != ri {
				continue
			}

			ln := len(o.R.Operations)
			if ln > 1 && i < ln-1 {
				o.R.Operations[i] = o.R.Operations[ln-1]
			}
			o.R.Operations = o.R.Operations[:ln-1]
			break
		}
	}

	return nil
}

func removeOperationsFromFilesSlice(o *File, related []*Operation) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Files {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Files)
			if ln > 1 && i < ln-1 {
				rel.R.Files[i] = rel.R.Files[ln-1]
			}
			rel.R.Files = rel.R.Files[:ln-1]
			break
		}
	}
}

// AddStorages adds the given related objects to the existing relationships
// of the file, optionally inserting them as new records.
// Appends related to o.R.Storages.
// Sets related.R.Files appropriately.
func (o *File) AddStorages(exec boil.Executor, insert bool, related ...*Storage) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"files_storages\" (\"file_id\", \"storage_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, query)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		_, err = exec.Exec(query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &fileR{
			Storages: related,
		}
	} else {
		o.R.Storages = append(o.R.Storages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &storageR{
				Files: FileSlice{o},
			}
		} else {
			rel.R.Files = append(rel.R.Files, o)
		}
	}
	return nil
}

// SetStorages removes all previously related items of the
// file replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Files's Storages accordingly.
// Replaces o.R.Storages with related.
// Sets related.R.Files's Storages accordingly.
func (o *File) SetStorages(exec boil.Executor, insert bool, related ...*Storage) error {
	query := "delete from \"files_storages\" where \"file_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeStoragesFromFilesSlice(o, related)
	if o.R != nil {
		o.R.Storages = nil
	}
	return o.AddStorages(exec, insert, related...)
}

// RemoveStorages relationships from objects passed in.
// Removes related items from R.Storages (uses pointer comparison, removal does not keep order)
// Sets related.R.Files.
func (o *File) RemoveStorages(exec boil.Executor, related ...*Storage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"files_storages\" where \"file_id\" = $1 and \"storage_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeStoragesFromFilesSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Storages {
			if rel != ri {
				continue
			}

			ln := len(o.R.Storages)
			if ln > 1 && i < ln-1 {
				o.R.Storages[i] = o.R.Storages[ln-1]
			}
			o.R.Storages = o.R.Storages[:ln-1]
			break
		}
	}

	return nil
}

func removeStoragesFromFilesSlice(o *File, related []*Storage) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Files {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Files)
			if ln > 1 && i < ln-1 {
				rel.R.Files[i] = rel.R.Files[ln-1]
			}
			rel.R.Files = rel.R.Files[:ln-1]
			break
		}
	}
}

// Files retrieves all the records using an executor.
func Files(mods ...qm.QueryMod) fileQuery {
	mods = append(mods, qm.From("\"files\""))
	return fileQuery{NewQuery(mods...)}
}

// FindFile retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindFile(exec boil.Executor, iD int64, selectCols ...string) (*File, error) {
	fileObj := &File{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"files\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, fileObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mdbmodels: unable to select from files")
	}

	return fileObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *File) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("mdbmodels: no files provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(fileColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	fileInsertCacheMut.RLock()
	cache, cached := fileInsertCache[key]
	fileInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			fileAllColumns,
			fileColumnsWithDefault,
			fileColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(fileType, fileMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(fileType, fileMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"files\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"files\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "mdbmodels: unable to insert into files")
	}

	if !cached {
		fileInsertCacheMut.Lock()
		fileInsertCache[key] = cache
		fileInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the File.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *File) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	fileUpdateCacheMut.RLock()
	cache, cached := fileUpdateCache[key]
	fileUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			fileAllColumns,
			filePrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("mdbmodels: unable to update files, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"files\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, filePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(fileType, fileMapping, append(wl, filePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to update files row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: failed to get rows affected by update for files")
	}

	if !cached {
		fileUpdateCacheMut.Lock()
		fileUpdateCache[key] = cache
		fileUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q fileQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to update all for files")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to retrieve rows affected for files")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o FileSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("mdbmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), filePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"files\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, filePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to update all in file slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to retrieve rows affected all in update all file")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *File) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("mdbmodels: no files provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(fileColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	fileUpsertCacheMut.RLock()
	cache, cached := fileUpsertCache[key]
	fileUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			fileAllColumns,
			fileColumnsWithDefault,
			fileColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			fileAllColumns,
			filePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("mdbmodels: unable to upsert files, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(filePrimaryKeyColumns))
			copy(conflict, filePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"files\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(fileType, fileMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(fileType, fileMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "mdbmodels: unable to upsert files")
	}

	if !cached {
		fileUpsertCacheMut.Lock()
		fileUpsertCache[key] = cache
		fileUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single File record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *File) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("mdbmodels: no File provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), filePrimaryKeyMapping)
	sql := "DELETE FROM \"files\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to delete from files")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: failed to get rows affected by delete for files")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q fileQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("mdbmodels: no fileQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to delete all from files")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: failed to get rows affected by deleteall for files")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o FileSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), filePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"files\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, filePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: unable to delete all from file slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mdbmodels: failed to get rows affected by deleteall for files")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *File) Reload(exec boil.Executor) error {
	ret, err := FindFile(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *FileSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := FileSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), filePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"files\".* FROM \"files\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, filePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "mdbmodels: unable to reload all in FileSlice")
	}

	*o = slice

	return nil
}

// FileExists checks if the File row exists.
func FileExists(exec boil.Executor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"files\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "mdbmodels: unable to check if files exists")
	}

	return exists, nil
}
